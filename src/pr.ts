import * as core from "@actions/core";
import * as github from "@actions/github";
import { ExtensionUpdate } from "./types";
import { groupUpdatesByType } from "./updates";

/**
 * Fetches release notes for a specific release
 * @param octokit GitHub API client
 * @param owner Repository owner
 * @param repo Repository name
 * @param version Release version (will try with and without 'v' prefix)
 * @returns Release notes body or null if not found
 */
async function fetchReleaseNotes(
	octokit: ReturnType<typeof github.getOctokit>,
	owner: string,
	repo: string,
	version: string,
): Promise<string | null> {
	const tagsToTry = version.startsWith("v") ? [version, version.slice(1)] : [version, `v${version}`];

	for (const tag of tagsToTry) {
		try {
			const { data: release } = await octokit.rest.repos.getReleaseByTag({
				owner,
				repo,
				tag,
			});
			return release.body || null;
		} catch (error) {
			core.debug(`Failed to fetch release notes for ${owner}/${repo}@${tag}: ${error}`);
		}
	}

	return null;
}

/**
 * Generates a Pull Request title
 * @param updates Array of extension updates
 * @param prefix Prefix for the PR title (default: "chore(deps):")
 * @returns PR title
 */
export function generatePRTitle(updates: ExtensionUpdate[], prefix = "chore(deps):"): string {
	if (updates.length === 1) {
		const update = updates[0];
		return `${prefix} update ${update.nameWithOwner} extension to ${update.latestVersion}`;
	}

	return `${prefix} update ${updates.length} Quarto extension${updates.length > 1 ? "s" : ""}`;
}

/**
 * Generates a detailed Pull Request body similar to Dependabot
 * @param updates Array of extension updates
 * @param octokit GitHub API client
 * @returns PR body in markdown format
 */
export async function generatePRBody(
	updates: ExtensionUpdate[],
	octokit: ReturnType<typeof github.getOctokit>,
): Promise<string> {
	const sections: string[] = [];

	sections.push("Updates the following Quarto extension(s):");
	sections.push("");

	const grouped = groupUpdatesByType(updates);

	if (grouped.major.length > 0) {
		sections.push("## ‚ö†Ô∏è Major Updates");
		sections.push("");
		sections.push(...formatUpdateList(grouped.major));
		sections.push("");
	}

	if (grouped.minor.length > 0) {
		sections.push("## ‚ú® Minor Updates");
		sections.push("");
		sections.push(...formatUpdateList(grouped.minor));
		sections.push("");
	}

	if (grouped.patch.length > 0) {
		sections.push("## üêõ Patch Updates");
		sections.push("");
		sections.push(...formatUpdateList(grouped.patch));
		sections.push("");
	}

	sections.push("---");
	sections.push("");

	for (const update of updates) {
		if (updates.length > 1) {
			sections.push(`### ${update.nameWithOwner}`);
			sections.push("");
		} else {
			sections.push("### Release Notes");
			sections.push("");
		}

		const parts = update.repositoryName.split("/");
		if (parts.length !== 2) {
			core.warning(`Invalid repository name format: ${update.repositoryName}`);
			continue;
		}
		const [owner, repo] = parts;
		const releaseBody = await fetchReleaseNotes(octokit, owner, repo, update.latestVersion);

		sections.push("<details>");
		sections.push(`<summary>Release ${update.latestVersion}</summary>`);
		sections.push("");

		if (releaseBody) {
			const quotedBody = releaseBody
				.split("\n")
				.map((line) => `> ${line}`)
				.join("\n");
			sections.push(quotedBody);
		} else {
			sections.push(`> No release notes available.`);
			sections.push(`>`);
			sections.push(`> View release: ${update.releaseUrl}`);
		}

		sections.push("");
		sections.push("</details>");
		sections.push("");

		if (update.description) {
			sections.push(`**About**: ${update.description}`);
			sections.push("");
		}

		sections.push(`**Links**: [Repository](${update.url}) ¬∑ [Release](${update.releaseUrl})`);
		sections.push("");
	}

	sections.push("---");
	sections.push("");
	sections.push(
		"ü§ñ This PR was automatically generated by [quarto-extensions-updater](https://github.com/mcanouil/quarto-extensions-updater)",
	);

	return sections.join("\n");
}

/**
 * Formats a list of updates as markdown
 * @param updates Array of extension updates
 * @returns Array of markdown lines
 */
function formatUpdateList(updates: ExtensionUpdate[]): string[] {
	const lines: string[] = [];

	for (const update of updates) {
		lines.push(
			`- **[${update.nameWithOwner}](${update.url})**: \`${update.currentVersion}\` ‚Üí \`${update.latestVersion}\``,
		);
	}

	return lines;
}

/**
 * Generates labels for the PR based on update types
 * @param updates Array of extension updates
 * @returns Array of label names
 */
export function generatePRLabels(updates: ExtensionUpdate[]): string[] {
	const labels = ["dependencies", "quarto-extensions"];

	const grouped = groupUpdatesByType(updates);

	if (grouped.major.length > 0) {
		// labels.push("major-update");
	}

	if (grouped.minor.length > 0) {
		// labels.push("minor-update");
	}

	if (grouped.patch.length > 0) {
		// labels.push("patch-update");
	}

	if (updates.length > 1) {
		// labels.push("multiple-updates");
	}

	return labels;
}

/**
 * Logs a summary of the updates
 * @param updates Array of extension updates
 */
export function logUpdateSummary(updates: ExtensionUpdate[]): void {
	core.info("üì¶ Extension Updates Summary:");
	core.info("‚îÄ".repeat(60));

	const grouped = groupUpdatesByType(updates);

	if (grouped.major.length > 0) {
		core.warning(`‚ö†Ô∏è  Major updates (${grouped.major.length}):`);
		for (const update of grouped.major) {
			core.warning(`   ${update.nameWithOwner}: ${update.currentVersion} ‚Üí ${update.latestVersion}`);
		}
	}

	if (grouped.minor.length > 0) {
		core.info(`‚ú® Minor updates (${grouped.minor.length}):`);
		for (const update of grouped.minor) {
			core.info(`   ${update.nameWithOwner}: ${update.currentVersion} ‚Üí ${update.latestVersion}`);
		}
	}

	if (grouped.patch.length > 0) {
		core.info(`üêõ Patch updates (${grouped.patch.length}):`);
		for (const update of grouped.patch) {
			core.info(`   ${update.nameWithOwner}: ${update.currentVersion} ‚Üí ${update.latestVersion}`);
		}
	}

	core.info("‚îÄ".repeat(60));
	core.info(`Total: ${updates.length} extension(s) to update`);
}
